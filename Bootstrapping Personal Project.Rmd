---
title: "Predicting Monthly Returns using Bootstrapping and Multiple Linear Regression"
output: pdf_document
date: '2022-10-07'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(quantmod)
options(scipen = 1000000)

GetData<-function(Ticker){
  #Gets stock data and log returns
  getSymbols(Ticker)
  returns<-monthlyReturn(get(Ticker),type = "log")+1
  
  if(length(returns)>30){
    #Removes how ever many return entries starting from the beginning(i.e. if the data is 2010-2020 it removes at 2010), to make returns divisible by 4
    returns<-returns[-c(1:(length(returns)%%4))]
    #Creates a matrix that is n=4 rows and m=length(returns)/4-3 columns(Minus 3 so no overlap)
    bstrap<<-matrix(nrow=4,ncol=round(length(returns)-3))
    #Nice little for loop to fill the matrix, columns are chronological and iterate by only 1 month not 4(i.e column1=month1->month4,column2=month2->month5,etc.)
    for(i in c(1:4)){
      bstrap[i,]<<-returns[c(i:(length(returns)-(4-i)))]
    }
    #Creates Variable that is # of columns in bstrap 
    Ncols<<-length(bstrap[1,])
  }
  else{
    print(paste(Ticker," - Not Enough Data to Select and Sample",sep = ""))
    return(FALSE)
  }
} 

#Function copied from Stack Exchange to retrieve p-val of model
lmp <- function (modelobject) {
  #Rejects argument if it is not a linear model
  if (class(modelobject) != "lm") stop("Not an object of class 'lm' ")
  #Extracts P-value from model
  f <- summary(modelobject)$fstatistic
  p <- pf(f[1],f[2],f[3],lower.tail=F)
  attributes(p) <- NULL
  #returns P-value
  return(p)
}

Select<-function(name,s,N,cc){
  #Creates Matrix "Expected" To hold estimated return, variance, and actual return, respectively
  Expected<<-matrix(ncol=3,nrow=Ncols)
  colnames(Expected)<<-c("x1","x2","y")
  
  slct<-function(x){
    #If x is less than (Ncols-(n*2)) it continues with the entire function, if not then it skips the the else at the bottom of the function that deals with the modelling
    if(x<(Ncols-(s*2))){
      #j is a data frame, where the first column is every correlation coefficient when comparing bstrap[c(1:3),i] with the three months prior to the month were trying to predict,
      #and the second column is the column index of said correlation Coefficient
      j<-data.frame(cor(bstrap[c(1:3),c(1:(Ncols-(x+1)))],bstrap[c(1:3),Ncols-x]),c(1:(Ncols-(x+1))))
      #Removes Values less than cc or equal to 1
      j<-j[cc<j[,1]&j[,1]<1,]
      #Uses the indexes in the second column of j to take the 4th month from bstrap
      HcorR<-c(bstrap[4,c(j[,2])])
      #If the length of HcorR is at least double the size of n it continues, this is done to ensure decent sampling(i.e. not resampling a sample of 10 from a dataset of length 11)    
      if(length(HcorR)>=(s*2)){
        #replicates the mean and variance of n samples from HcorR and puts the estimated return(mean of means), variance(mean of variances), and actual return into a dataframe
        Expected[x+1,c(1:3)]<<-c(mean(replicate(n=N,mean(sample(HcorR,s,replace = TRUE)))),mean(replicate(n=N,var(sample(HcorR,s,replace = TRUE)))),bstrap[4,Ncols-x])
        slct(x+1)
      }
      #If the length of HcorR is NOT at least double the size of n it goes the the next column(Ncols-(x+1)) and repeats
      else{
        slct(x+1)
      }
    }
    #if x>=(Ncols-(n*2)), then we model our data
    else{
      #Removes rows where length(HcorR)<=(n*2)
      Expected<<-Expected[complete.cases(Expected),]
      #Ensures there's enough data to form a model
      try<-try(length(Expected[,1]),silent = TRUE)
      if(class(try) != 'try-error'){
        if(length(Expected[,1])>1){
          #Makes a linear model of the actual returns as a function of the expected return and expected variance
          Expected<<-data.frame(Expected)
          Model<-lm(y~x1+x2,Expected)
          #Assigns the R-squared and P-value of the model to respective variables
          R2<-summary(Model)$r.squared
          P<-lmp(Model)
          #Puts these variables into a vector
          Rsqr<<-c(Rsqr,R2)
          Pval<<-c(Pval,P)
          
          #if the current model is better than the last model based on the parameters below, the current model becomes the new "best" model
          if((0<P & P<.05) & (Rsqr[length(Rsqr)-1]<R2 & R2>.25) & length(Model$residuals)>9){
            BEST_Model<<-Model
            BEST_cc<<-cc
          }
        }
        else{
          Rsqr<<-c(Rsqr,NaN)
          Pval<<-c(Pval,NaN)
        }
      }
      else{
        Rsqr<<-c(Rsqr,NaN)
        Pval<<-c(Pval,NaN)
      }
    }
  }
  slct(0)
}

slct2<-function(mdl,cc,s,N,name){
    #Creates matrices "Estimate" and "Prediction" which will be used to store outputs
    Estimate<-matrix(ncol=4,nrow=1)
    colnames(Estimate)<-c("Boot-Strapped Expected Return","Avg. Variance of Boot-Strapped Samples","CC","Size of Sampling Pool")
    Prediction<-matrix(ncol=5,nrow=1)
    colnames(Prediction)<-c("Number of Residuals","R-squared of Model","P-value of Model","MSE(Kinda)", "Model Prediction")
    #j is a vector of every correlation coefficient when comparing bstrap[c(1:3),i] with the most recent three months
    j<-data.frame(cor(bstrap[c(1:3),c(1:(Ncols-1))],bstrap[c(2:4),Ncols]),c(1:(Ncols-1)))
    #Removes Values less than cc or equal to 1
    j<-j[cc<j[,1]&j[,1]<1,]
    #Uses the indexes in the second column of j to take the 4th month from bstrap
    HcorR<-c(bstrap[4,c(j[,2])])
    #If the length of HcorR is at least double the size of n it continues, this is done to ensure decent sampling(i.e. not resampling a sample of 10 from a dataset of length     11)    
    if(length(HcorR)>=(s*2)){
      #replicates the mean and variance of n samples from HcorR and puts the estimated return(mean of means), variance(mean of variances),Size of sample pool,
      #R-squared of best model, and P-value of best model into a dataframe
      Estimate[1,c(1:4)]<-c(mean(replicate(n=N,mean(sample(HcorR,s,replace = TRUE)))),mean(replicate(n=N,var(sample(HcorR,s,replace = TRUE)))),cc,length(HcorR))
      Prediction[1,c(1:4)]<-c(length(mdl$residuals),summary(mdl)$r.squared,lmp(mdl),sqrt((sum((mdl$residuals)^2)/length(mdl$residuals))))
      
      #Makes a prediction using the best model and new estimated parameters
      D2<-data.frame(as.numeric(Estimate[,1]),as.numeric(Estimate[,2]))
      colnames(D2)<-c("x1","x2")
      
      #Assigns the prediction to the dataframe Prediction, which is then assigned to a variable corresponding to "name"
      Prediction[1,5]<-predict(mdl,newdata=D2)
      print(paste(name," - Significant Model Found",sep = ""))
      return(assign(paste(name,"_DATA", sep = ""),list(Prediction,Estimate,mdl),envir = globalenv()))
    }
    #If the length of HcorR is NOT at least double the size of n it print error below
    else{
      print(paste(name," - Not Enough Data to Select and Sample",sep = ""))
    }
}

#WM_nms<-c("BLK","BAM","BX","KKR","BK","AMP","APO","TROW","STT","NTRS")
#Pharm_nms<-c("JNJ","LLY","PFE","NVO","MRK","RHHBY","AZN","NVS","BMY","AMGN")
#RealEst_nms<-c("AMT","PLD","CCI","EQIX","PSA","O","SBAC","SPG","NLY","VICI")

Predict<-function(stonks,CCseq){
  cycl<-function(z){
    #If all tickers have been run through model program ends
    if(z==(length(stonks)+1)){
      return("Complete")
    }
    #Necessary for model discrimination in Select(), less-than-elegant
    Rsqr<<-c(0)
    Pval<<-c(0)
    BEST_Model<<-c()
    BEST_cc<<-c()
    #Skips ticker if data can't be pulled or there isn't enough data to create bstrap
    t<-try(GetData(stonks[z]))
    if(t != 'try-error' & t != FALSE){
      #Calls GetData()
      GetData(stonks[z])
      #Iterates through CC's .5->.95 in .05 increments, does the data selection via Select() for each CC, then stores the pval and R^2 of the model
      for(i in CCseq){
        Select(stonks[z],10,10000,i)  
      }
      #Removes 0's(again, less-than-elegant)
      Rsqr<-Rsqr[-1]
      Pval<-Pval[-1]
      
      #If valid model is found, prediction is made via calling slct2()
      if(is.null(BEST_cc) == FALSE & is.null(BEST_Model) == FALSE){
          slct2(BEST_Model,BEST_cc,10,10000,stonks[z])
          cycl(z+1)
      }
      else{
        print(paste(stonks[z]," - All Models Are Insignificant or Explain Less Than 25% of Total Variance",sep = ""))
        cycl(z+1)
      }
    }
    else{
      cycl(z+1)
    }
  }
  cycl(1)
  rm(BEST_Model,bstrap,Expected,Ncols,BEST_cc,Pval,Rsqr,envir = globalenv())
}

Predict(c("TWTR"),seq(.5,.9,.1))
```
